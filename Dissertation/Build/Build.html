<!DOCTYPE html>
<html>

<head>
  <title>3D Level Design Tool</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="style.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
</head>
<body>
  <!-- GUI -->
  <div class="icons">
    <img src='Assets/Icons/Burger.png' onmouseover="this.src='Assets/Icons/BurgerHover.png';" onmouseout="this.src='Assets/Icons/Burger.png';" href="#" onclick="openSideMenu()" alt="T" id="burger"/>
    <img src='Assets/Icons/Snap.png' onmouseover="this.src='Assets/Icons/SnapHover.png';" onmouseout="this.src='Assets/Icons/Snap.png';" href="#" onclick="toggleSnap()" alt="T" id="icon" />
    <img src='Assets/Icons/Translate.png' onmouseover="this.src='Assets/Icons/TranslateHover.png';" onmouseout="this.src='Assets/Icons/Translate.png';" href="#" onclick="toggleTransform('translate')" alt="T" id="icon" />
    <img src='Assets/Icons/Rotate.png' onmouseover="this.src='Assets/Icons/RotateHover.png';" onmouseout="this.src='Assets/Icons/Rotate.png';" href="#" onclick="toggleTransform('rotate')" alt="R" id="icon" />
    <img src='Assets/Icons/Scale.png' onmouseover="this.src='Assets/Icons/ScaleHover.png';" onmouseout="this.src='Assets/Icons/Scale.png';" href="#" onclick="toggleTransform('scale')" alt="S" id="icon" />
    <img src='Assets/Icons/Info.png' onmouseover="this.src='Assets/Icons/InfoHover.png';" onmouseout="this.src='Assets/Icons/Info.png';" href="#" onclick="showInfo()" alt="I" id="icon" />
  </div>
  <div id="SideBar">
    <div id="SettingsMenu" class="nav">
      <ul class="SideBarUl">
        <!-- Header -->
        <li href="#" class="close">
          <div>
            <h1>3D Level Design Tool
              <h2>Jack Smerdon</h2>
            </h1>
          </div>
          <a = href="#" onclick="closeSideMenu()">X</a>
        </li>

        <!-- Camera Settings -->
        <li class="camera"><a>Camera</a>
          <ul class="cameraDark">
            <li><a>Auto Rotate
              <label class="switch">
                <input type="checkbox"  onclick="toggleAutoRotate()">
                <span class="slider round"></span>
              </label></a>
            </li>
            <li><a>Rotation Lock
              <label class="switch">
                <input type="checkbox"  onclick="toggleRotationLock()" checked>
                <span class="slider round"></span>
              </label></a>
            </li>
            <li><a href="#" onclick="toggleCamReset()">Reset</a></li>
          </ul>
        </li>

        <!-- Model Settings -->
        <li class="models"><a>Models</a>
          <ul class="modelsDark">
            <li><a href="#">Load New Model:</a>
              <ul>
                <a>Model:</a>
                <input type="file" id="NewModel" accept=".obj">
                <a>Material:</a>
                <input type="file" id="NewMaterial" accept=".mtl">
                <a>Texture:</a>
                <input type="file" id="NewTexture" accept=".png">

                <a href='#' onClick="loadNewModel()">Load Model</a>
              </ul>
            </li>
            <li><a>Objects in Scene:</a>
              <ul id="Objects">
                <li id="ObjectsBottom"></li>
              </ul>
            </li>
          </ul>
        </li>

        <!-- Prefab Settings -->
        <li class="prefab"><a>Prefabs</a>
          <ul class="prefabDark">
            <li><a>Generate Primative:</a>
              <ul>
                <a href="#" onclick="spawnBox()">Box</a>
                <a href="#" onclick="spawnCylinder()">Cylinder</a>
                <a href="#" onclick="spawnPlane()">Plane</a>
                <a href="#" onclick="spawnSphere()">Sphere</a>
                <a href="#" onclick="spawnText()">Text</a>
              </ul>
            </li>
            <li><a>Other:</a>
              <ul>
                <a href="#" onclick="loadFromFile('Monkey')">Monkey</a>
                <a href="#" onclick="loadFromFile('Donut')">Donut</a>
                <a href="#" onclick="loadFromFile('Planet')">Planet</a>
              </ul>
            </li>
            <li><a>Water
              <label class="switch">
                <input type="checkbox" onclick="toggleWater()">
                <span class="slider round"></span>
              </label></a>
            </li>
            <li><a>Grid
              <label class="switch">
                <input type="checkbox" onclick="toggleGrid()"checked>
                <span class="slider round"></span>
              </label></a>
            </li>

          </ul>
        </li>

        <!-- Lighting Settings -->
        <li class="lighting"><a>Lighting</a>
          <ul class="lightingDark">
            <li><a>Existing Lights:</a>
              <ul id="Lights">
              <ul id="LightsBottom"></ul>
            </ul>
            <li ><a href="#" onclick="addLight('Point')">Spawn Light</a></li>
          </ul>
        </li>

        <!-- Rendering Settings -->
        <li class="rendering"><a>Rendering</a>
          <ul class="renderingDark">
            <li><a href="#" onclick=""></a></li>
          </ul>
        </li>

        <!-- Skybox Settings -->
        <li class="skybox"><a>Skybox</a>
          <ul class="skyboxDark">
            <li><a>Textures:</a>
              <ul>
                <a>Front:</a>
                <input type="file" id="NewFrontIMG" accept="image/*">

                <a>Back:</a>
                <input type="file" id="NewBackIMG" accept="image/*">

                <a>Up:</a>
                <input type="file" id="NewUpIMG" accept="image/*">

                <a>Down:</a>
                <input type="file" id="NewDownIMG" accept="image/*">

                <a>Right:</a>
                <input type="file" id="NewRightIMG" accept="image/*">

                <a>Left:</a>
                <input type="file" id="NewLeftIMG" accept="image/*">
                <a href="#" onclick="updateSkybox()">Reload</a>
              </ul>
            </li>

            <li><a>Help:</a>
              <ul>
                <a href="#" onclick="loadSkybox('Default')">Reset to Default</a>
                <a href="#" onclick="loadSkybox('Helper')">Helper Textures</a>
              </ul>
            </li>
            <li><a>Sample:</a>
              <ul>
                <a href="#" onclick="loadSkybox('Jungle')">Jungle</a>
                <a href="#" onclick="loadSkybox('Sky')">Sky</a>
                <a href="#" onclick="loadSkybox('Space')">Space</a>
              </ul>
            </li>
            <li><a>Settings:</a>
              <ul>
                <a>Size</a>
                <div class="slidecontainer">
                  <input type="range" min="0" max="15000" value="10000" class="rangeSlider" id="skybox" step="1">
                </div>
              </ul>
            </li>
          </ul>
        </li>

        <!-- Scene Settings -->
        <li class="scene"><a>Scene</a>
          <ul class="sceneDark">
            <li><a>Settings:</a>
              <ul>
                <a>Fog</a>
                <div class="slidecontainer">
                  <input type="range" min="0" max="0.085" value="0" class="rangeSlider" id="fog" step="0.0001">
                </div>
                <a>Grid Size</a>
                <div class="slidecontainer">
                  <input type="range" min="2" max="499" value="50" class="rangeSlider" id="grid" step="2">
                  <output  id="range_weight_disp"></output>
                </div>
              </ul>
            </li>
            <li><a>Sample Scenes:</a>
              <ul>
                <a>Jungle</a>
                <a>Island</a>
                <a>Sky</a>
              </ul>
            </li>
            <li><a>Load Scene:</a>
              <ul>
                  <a><input type="file" id="NewGLTF" accept=".gltf" style="font-size: 10px;"></a>
                  <a href="#" onclick="loadScene()">Load GLTF</a>
              </ul>
            </li>
            <li><a>Save Scene:</a>
              <ul>
                  <a href="#" onclick="saveScene()">Save as GLTF</a>
                  <a href="#" onclick="saveScene()">Save as OBJ</a>
              </ul>
            </li>
            <li><a href="#" onclick="clearScene()">New Scene</a></li>
          </ul>
        </li>

        <!-- Properties -->
        <li class="properties"><a>Properties</a>
          <ul class="Focus">
              <h1 id="header">Select Object</h1>
              <canvas id="picker"></canvas>
              <div class="dropdown">
                <button id="dropbtn">Select Material</button>
                <div class="dropdown-content">
                  <ul id="MatListTop">
                    <ul id="MatListBottom"></ul>
                  </ul>
                </div>
              </div>
              <div class="controls">
                <div><label>R</label> <input type="text" id="rVal" /></div>
                <div><label>G</label> <input type="text" id="gVal" /></div>
                <div><label>B</label> <input type="text" id="bVal" /></div>
                <div><label>HEX</label> <input type="text" id="hexVal" /></div>
              </div>
              <a href="#" onclick="removeObject()">Remove Object</a>
          </ul>
        </li>
      </ul>
    </div>
  </div>

  <!-- Includes -->
  <script src="Imports/three.js"></script>
  <script src="Imports/Detector.js"></script>
  <script src="Imports/TransformControls.js"></script>
  <script src="Imports/OrbitControls.js"></script>
  <script src="Imports/OBJLoader.js"></script>
  <script src="Imports/MTLLoader.js"></script>
  <script src="Imports/GLTFLoader.js"></script>
  <script src="Imports/GLTFExporter.js"></script>
  <script src="Imports/Water.js"></script>
  <script src="Imports/jquery.js"></script>

  <!-- Program -->
  <div class="container"></div>
  <script>

  //Displays message to the user if webGL is not supported in the browser.
  if (!Detector.webgl) { Detector.addGetWebGLMessage(); }

  //Globals
  var container = document.createElement('div');
  document.getElementsByClassName("container")[0].appendChild(container);
  var scene = new THREE.Scene();
  var snap = false;

  //Raycasting
  var Raycasts = [];
  var raycastCount = 0;
  var raycaster = new THREE.Raycaster();
  raycaster.far = 10000;
  var mouse = new THREE.Vector2(), INTERSECTED;
  var raycastEnabled = true;

  //Object Selection & Modification
  var selectedObject;
  var objectMaterials = [];
  var selectedMaterial;

  var Lights = [];
  var lightCount = 0;

  var gridSize = 50;
  var skyboxSize = new THREE.Vector3(100,100,100);

  //Only 1 permitted per scene
  var skybox, grid, water;
  var camera, control, orbit, renderer;

  var windowHalfX = window.innerWidth / 2;
  var windowHalfY = window.innerHeight / 2;

  init();
  animate();

  /* Utils */
  function toRadians (angle) {
    return angle * (Math.PI / 180);
  }

  /* Init */
  function animate() {
    requestAnimationFrame(animate);
    update();
    render();
  }
  function render() {
    if(scene.getObjectByName("Water"))
    {
        water.material.uniforms[ "time" ].value += 1.0 / 600.0;
    }

    renderer.render(scene, camera);
    /*// Stops user from refreshing the page
    window.onbeforeunload = function() {
        return "Leaving the page without saving will result in loss of data. Do you wish to continue?";
    }
    */
  }
  function init() {
    closeSideMenu();
    setupCamera(0, 7, 15, 0.1, 10000);

    //Events
    window.addEventListener('resize', onWindowResize, false);
    window.addEventListener( 'mousedown',onDocumentMouseDown, false );
    window.addEventListener( 'mousemove', onMouseMove, false );
    window.addEventListener( 'resize', onWindowResize, false );

    //To be replaced by GLTF load
    //spawnPlane();
    spawnGrid();
    spawnWater();
    addLight("Directional");
    //addLight("Ambient");
    loadSkybox("Default");
    toggleGrid()
    updateList("Objects", Raycasts);
    updateList("Lights", Lights);

    //Log for debugging
    console.log("Default Scene Hierarchy", scene);
  }
  function update() {
    orbit.update();

    if(Raycasts.length != raycastCount)
    {
      raycastCount = Raycasts.length;
      updateList("Objects", Raycasts);
    }

    if(Lights.length != lightCount)
    {
      lightCount = Lights.length;
      updateList("Lights", Lights);
    }

    if (selectedObject != control.object)
    {
      var header = document.getElementById("header");
      selectedObject = control.object;
      if(selectedObject)
      {
        header.textContent = selectedObject.name;
        updateProperties(selectedObject);
      }
      else {
        header.textContent = "Select Object";
      }
      var btn = document.getElementById("dropbtn");
      btn.textContent = "Select Material";
      selectedMaterial = null;
    }

    var gridSlider = document.getElementById("grid");
    gridSlider.oninput = function () {
      toggleGrid();
      gridSize = this.value;
      grid = null;
      spawnGrid();
      toggleGrid();
    }

    var fogSlider = document.getElementById("fog");
    fogSlider.oninput = function () {
      scene.fog = new THREE.FogExp2(0xffffff, this.value);
    }

    var skyboxSlider = document.getElementById("skybox");
    skyboxSlider.oninput = function () {
      skyboxSize = this.value;
      updateSkyboxSize();
    }
  }
  function setupCamera(x, y, z, near, far) {
    /* Camera */
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, near, far);
    camera.position.x = x;
    camera.position.y = y;
    camera.position.z = z;
    camera.target = camera.position;

    /* Renderer */
    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(new THREE.Color("hsl(0, 0%, 10%)"));
    container.appendChild(renderer.domElement);

    orbit = new THREE.OrbitControls(camera, renderer.domElement);
    orbit.enableDamping = true;
    orbit.dampingFactor = 0.08;
    orbit.enableZoom = true;
    orbit.minDistance = 3;
    orbit.autoRotate = false;
    orbit.autoRotateSpeed = -0.1;
    orbit.maxPolarAngle = 1.5;
    orbit.keyPanSpeed = 5;
		orbit.update();
		orbit.addEventListener( 'change', render );

		control = new THREE.TransformControls( camera, renderer.domElement );
		control.addEventListener( 'change', render );
		control.addEventListener( 'dragging-changed', function ( event ) {
		  orbit.enabled = ! event.value;
      raycastEnabled =! event.value;
		} );
  }
  function onWindowResize() {
    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
  }
  function onMouseMove( event ) {
	  //calculate mouse position in normalized device coordinates

	  mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

  }
  function onDocumentMouseDown( e ) { //Raycasting

    raycaster.setFromCamera( mouse, camera );
    var intersects = raycaster.intersectObjects( Raycasts, true );

    if(intersects.length === 0)
    {
      if(raycastEnabled)
      {
        control.detach();
        scene.remove( control );
      }
    }
    else if(raycastEnabled)
    {
      if ( intersects.length > 0 ) {
        if ( INTERSECTED != intersects[0].object ) {
          for (var i = 0; i < Raycasts.length; i++) {
            if (intersects[0].object.parent === Raycasts[ i ]) {
              control.attach( Raycasts[i] );
              scene.add( control );
            }
            else if (intersects[0].object === Raycasts[ i ]) {
              control.attach( Raycasts[i] );
              scene.add( control );
            }
          }
        }
      }
    }

    /*//Old code with model highlight
  if ( intersects.length > 0 ) {
    if ( INTERSECTED != intersects[ 0 ].object ) {
      var outlineMaterial = new THREE.MeshBasicMaterial( { color: 0x00ffff, side: THREE.BackSide } );

      for (var i = 0; i < Raycasts.length; i++) {
          if (intersects[ 0 ].object.parent === Raycasts[ i ]) {
            SelectedObject.position = Raycasts[i].position;
            SelectedObject.add(Raycasts[i]);
            var group = new THREE.Object3D();      //create an empty container

            Raycasts[i].traverse( function ( child ) {
              if (child instanceof THREE.Mesh)
              {
                var outlineMesh = new THREE.Mesh(child.geometry, outlineMaterial);
                outlineMesh.scale.multiplyScalar(1.01);
                outlineMesh.position = child.position;
                outlineMesh.name = "outlineMesh";
                group.add(outlineMesh);
              }
            });

            SelectedObject.add(group);
            var axesHelper = new THREE.AxesHelper( 5 );
            SelectedObject.add(axesHelper);
          }
        }
        SelectedObject.translateZ(1);
        console.log(scene);
        //scene.add(SelectedObject);
      }
    }
  }
  */}

  /* SideBar Controls */
  function showInfo() {

  }
  function toggleTransform(type) {

    control.setMode( type );
  }
  function toggleSnap() {
    snap = !snap;
    if(snap) {
      control.setTranslationSnap( (gridSize/2) / (gridSize/2 + 1) );
      control.setRotationSnap( THREE.Math.degToRad( 15 ) );
    }
    else {
      control.setTranslationSnap( null );
      control.setRotationSnap( null );
    }
  }
  //Camera
  function toggleAutoRotate () {
    orbit.autoRotate = !orbit.autoRotate;
  }
  function toggleRotationLock() {
    if (orbit.maxPolarAngle === 1.5)
    {
      orbit.maxPolarAngle = Math.PI;
    }
    else {
      orbit.maxPolarAngle = 1.5;
    }
    orbit.update();
  }
  function toggleCamReset () {
    orbit.reset();
  }
  //Models
  function loadNewModel() {
    var newModel = document.getElementById('NewModel').files[0];
    var OBJFile = URL.createObjectURL( newModel );

    var newMat = document.getElementById('NewMaterial').files[0];
    var MTLFile = URL.createObjectURL( newMat );

    var newTex = document.getElementById('NewTexture').files[0];
    var JPGFile = URL.createObjectURL( newTex );

    var manager = new THREE.LoadingManager();

    manager.setURLModifier (function ( url ) {
      url = JPGFile;
    });

    var objLoader = new THREE.OBJLoader();
    var mtlLoader = new THREE.MTLLoader(manager);
    var texLoader = new THREE.TextureLoader();

    if(typeof document.getElementById('NewModel').files[0] !== 'undefined')
    {
      if(typeof document.getElementById('NewTexture').files[0] !== 'undefined')
      {
        mtlLoader.setResourcePath(JPGFile);
        mtlLoader.load(MTLFile, function (materials) {
          console.log(mtlLoader);
          materials.preload();
          objLoader.setMaterials(materials)
          objLoader.load(OBJFile, function (object) {
            var texture = texLoader.load(JPGFile);
            console.log(texture);
            object.traverse(function (child) {
            if (child instanceof THREE.Mesh) {
                child.material.map = texture;
            }
          });
          scene.add(object);
          });
        });
      }
    }
  }
  function updateList(listToUpdate, container){

    var list = document.getElementById(listToUpdate);
    while (list.firstChild) {
      list.removeChild(list.firstChild);
    }

    container.forEach(function(element) {
    {
        var newLi = document.createElement("li");
        newLi.setAttribute('id', element.name);
        var newA = document.createElement("a");
        newA.setAttribute('href', "#");
        newA.setAttribute('onclick', "select" + listToUpdate + "('" + element.name + "')");
        var newContent = document.createTextNode(element.name);
        newA.appendChild(newContent);
        newLi.appendChild(newA);

        var parentLocation = document.getElementById(listToUpdate);
        var insertLocation = document.getElementById(listToUpdate + "Bottom");
        parentLocation.insertBefore(newA, insertLocation);
      }
    });


  }
  function selectObjects(item){
    for (var i = 0; i < Raycasts.length; i++) {
      if (item === Raycasts[ i ].name) {
        control.attach( Raycasts[i] );
        scene.add( control );
        i = Raycasts.length;
      }
    }

  }
  //Prefabs
  function spawnBox() {
    var geometry = new THREE.BoxGeometry( 1, 1, 1 );
    var material = new THREE.MeshPhongMaterial( {color: 0xaaaaaa} );
    var cube = new THREE.Mesh( geometry, material );
    cube.name = "Cube";
    scene.add(cube);
    Raycasts.push(cube);
  }
  function spawnCylinder() {
    var geometry = new THREE.CylinderGeometry( 5, 5, 20, 32 );
    var material = new THREE.MeshPhongMaterial( {color: 0xaaaaaa} );
    var cylinder = new THREE.Mesh( geometry, material );
    scene.add( cylinder );
    cylinder.name = "Cylinder";
    Raycasts.push(cylinder);
  }
  function spawnPlane(x = 50, y = 50) {
    var planeGeometry = new THREE.PlaneGeometry( x, y, 1, 1 );
    var planeMaterial = new THREE.MeshPhongMaterial( {color: 0x707070, side: THREE.DoubleSide} );
    var plane = new THREE.Mesh( planeGeometry, planeMaterial );
    plane.rotation.x = toRadians(90);
    plane.receiveShadow = true;
    plane.name = "Plane";
    scene.add( plane );
    Raycasts.push(plane);
    planeSize = new THREE.Box3().setFromObject( plane );

  }
  function spawnSphere() {
    var geometry = new THREE.SphereGeometry( 5, 32, 32 );
    var material = new THREE.MeshPhongMaterial( {color: 0xaaaaaa} );
    var sphere = new THREE.Mesh( geometry, material );
    sphere.name = "Sphere";
    scene.add( sphere );
    Raycasts.push(sphere);
  }
  function spawnText() {
    var loader = new THREE.FontLoader();
				loader.load( 'Assets/Fonts/helvetiker_regular.typeface.json', function ( font ) {
					var textGeo = new THREE.TextBufferGeometry( "Made with Jack's Tool", {
						font: font,
						size: 8,
						height: 2,
						curveSegments: 5,
						bevelThickness: 1,
						bevelSize: 1,
						bevelEnabled: false
					} );
					textGeo.computeBoundingBox();
					var centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );
					var textMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000, specular: 0xffffff } );
					var mesh = new THREE.Mesh( textGeo, textMaterial );
					mesh.position.x = centerOffset;
					mesh.position.y = 0;
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					scene.add( mesh );
          Raycasts.push( mesh );
				} );

  }
  function loadFromFile(name) {
    var mtlLoader = new THREE.MTLLoader();
    mtlLoader.setPath('Assets/Models/');
    mtlLoader.load( (name + '.mtl'), function( materials )
    {
      materials.preload();

      var objLoader = new THREE.OBJLoader();

      objLoader.setMaterials( materials );
      objLoader.setPath('Assets/Models/');
      objLoader.load( (name + '.obj'), function ( object ) {

        model = object;

        var group = new THREE.Object3D();
        model.traverse( function ( child ) {
          if (child instanceof THREE.Mesh)
          {
              child.castShadow = true;
          }
        });

        //Needs to find bottom of object and set point to 0
        model.translateY(1.5);

        model.name = name;
        scene.add(model);
        Raycasts.push(model);
      } );
    } );
  }
  function spawnGrid() {
    grid = new THREE.GridHelper(gridSize, gridSize/2 + 1);
    grid.name = "Grid";
  }
  function toggleGrid() {
    if(scene.getObjectByName("Grid"))
    {
      control.detach();
      scene.remove( control );
      scene.remove(grid);
      for( var i = 0; i < Raycasts.length; i++){
       if ( Raycasts[i].name === "Grid") {
         Raycasts.splice(i, 1);
       }
      }
    }
    else {
      scene.add(grid);
      Raycasts.push(grid);
    }
  }
  function spawnWater() {
    var waterGeometry = new THREE.PlaneBufferGeometry( 50, 50 );

    water = new THREE.Water(
      waterGeometry,
      {
        textureWidth: 512,
        textureHeight: 512,
        waterNormals: new THREE.TextureLoader().load( 'Assets/Water.png', function ( texture ) {

        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

        } ),
        alpha: 1.0,
        sunDirection: new THREE.Vector3(10,10,10).normalize(),
        sunColor: 0x000000,
        waterColor: 0x5b696e,
        distortionScale: 25,
        fog: scene.fog !== undefined
      }
    );
    water.rotation.x = -Math.PI / 2;
    water.name = "Water";
    water.material.transparent = true;
  }
  function toggleWater() {
    if(scene.getObjectByName("Water"))
    {
      control.detach();
      scene.remove( control );
      scene.remove(water);
      for( var i = 0; i < Raycasts.length; i++){
       if ( Raycasts[i].name === "Water") {
         Raycasts.splice(i, 1);
       }
      }
    }
    else {
      scene.add(water);
      Raycasts.push(water);
    }
  }
  //Lighting
  function addLight (type) {
    var light;
    switch (type)
    {
      case "Ambient":
      {
        light = new THREE.AmbientLight(0xffffff, 1.0);
        light.intensity = 0.5;
        light.name = "Ambient Light";
        break;
      }
      case "Directional":
      {
        light = new THREE.DirectionalLight(0xffe6b8, 1)
        light.name = "Directional Light";
        light.position.set(0,30,0);
        var target = new THREE.Object3D();
        target.position.set(0,0,0);
        light.target = target;

        light.shadow.camera.left = -10;
        light.shadow.camera.right = 10;
        light.shadow.camera.top = 10;
        light.shadow.camera.bottom = -10;
        light.shadow.camera.near = 10;
        light.shadow.camera.far = 400;
        light.shadow.mapSize.width = 2048;
        light.shadow.mapSize.height = 2048;
        light.castShadow = true;
        break;
      }

      case "Point":
      {
        var light = new THREE.PointLight( 0xff0000, 1, 100 );
        light.position.set( 50, 50, 50 );
        light.name = "Point Light";
        break;
      }
    }

    scene.add(light);
    Lights.push(light);
  }
  function selectLights(item){
    for (var i = 0; i < Lights.length; i++) {
      if (item === Lights[ i ].name) {
        control.attach( Raycasts[i] );
        scene.add( control );
        i = Lights.length;
      }
    }

  }
  //Rendering
  //Skybox
  function updateSkybox(){

    scene.remove(skybox);

    var front = document.getElementById('NewFrontIMG').files[0];
    var frontURL = URL.createObjectURL( front );

    var back = document.getElementById('NewBackIMG').files[0];
    var backURL = URL.createObjectURL( back );

    var up = document.getElementById('NewUpIMG').files[0];
    var upURL = URL.createObjectURL( up );

    var down = document.getElementById('NewDownIMG').files[0];
    var downURL = URL.createObjectURL( down );

    var right = document.getElementById('NewRightIMG').files[0];
    var rightURL = URL.createObjectURL( right );

    var left = document.getElementById('NewLeftIMG').files[0];
    var leftURL = URL.createObjectURL( left );

    var skyboxGeometry = new THREE.CubeGeometry(skyboxSize);
    skyboxMaterials =
    [
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load(frontURL), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load(backURL), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load(upURL), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load(downURL), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load(rightURL), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load(leftURL), side: THREE.DoubleSide})
    ];

    skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
    scene.add(skybox);
  }
  function loadSkybox(name) {
    scene.remove(skybox);
    var skyboxGeometry = new THREE.CubeGeometry(10000, 10000, 10000);
    var skyboxMaterials =
    [
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load("Assets/Skybox/" + name + "/Front.png"), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load("Assets/Skybox/" + name + "/Back.png"), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load("Assets/Skybox/" + name + "/Up.png"), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load("Assets/Skybox/" + name + "/Down.png"), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load("Assets/Skybox/" + name + "/Right.png"), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load("Assets/Skybox/" + name + "/Left.png"), side: THREE.DoubleSide})
    ];

    skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
    skybox.name = "Skybox";
    scene.add (skybox);
  }
  function updateSkyboxSize(){
    scene.remove(skybox);
    var materials = skybox.material;
    var skyboxGeometry = new THREE.CubeGeometry(skyboxSize, skyboxSize, skyboxSize);
    skybox = new THREE.Mesh(skyboxGeometry, materials);
    scene.add(skybox);
  }
  //Scene
  function loadScene(){
    var loader = new THREE.GLTFLoader();
    var newGLTF = document.getElementById('NewGLTF').files[0];
    var gltfURL = URL.createObjectURL( newGLTF );

    loader.load( gltfURL, function ( gltf ) {
      scene = gltf.scene;
		  gltf.animations; // Array<THREE.AnimationClip>
		  gltf.scene; // THREE.Scene
		  gltf.scenes; // Array<THREE.Scene>
		  gltf.cameras; // Array<THREE.Camera>
		  gltf.asset; // Object

      gltf.scene.traverse( function ( child )
      {
        if (child instanceof THREE.Mesh)
        {
          Raycasts.push(child);
        }
      });
	  },
	  // called while loading is progressing
	  function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); },
	  // called when loading has errors
	  function ( error ) { console.log( 'An error happened' ); }
  );}
  function saveScene(){
    var gltfExporter = new THREE.GLTFExporter();

    gltfExporter.parse( Raycasts, function ( result ) {

      if ( result instanceof ArrayBuffer ) {

        saveArrayBuffer( result, 'scene.glb' );

      } else {

        var output = JSON.stringify( result, null, 2 );
        console.log( output );
        saveString( output, 'scene.gltf' );

      }

    });
  }
  function clearScene() {
    while(scene.children.length > 0)
    {
      scene.remove(scene.children[0]);
      Raycasts = [];
    }
    toggleGrid();
    addLight("Ambient");
  }
  //Properties
  function removeObject(){
    control.detach();
    scene.remove( control );
    scene.remove(selectedObject);
    for( var i = 0; i < Raycasts.length; i++){
     if ( Raycasts[i].name === selectedObject.name) {
       Raycasts.splice(i, 1);
     }
    }
  }
  function updateProperties (obj) {
    //dynamically add materials to List
    //give them materialClick fnction
    //change picker code to affect selected material

    objectMaterials = [];

    var parentLocation = document.getElementById("MatListTop");
    while (parentLocation.firstChild) {
      parentLocation.removeChild(parentLocation.firstChild);
    }

    obj.traverse( function ( child )
    {
      if (child instanceof THREE.Mesh)
      {
        objectMaterials = child.material;
        console.log(objectMaterials);
        for(var idx = 0; idx < objectMaterials.length; idx++)
        {
          var newA = document.createElement("a");
          newA.setAttribute('href', "#");
          newA.setAttribute("onclick","materialClick('" + idx + "')");
          var newContent = document.createTextNode(objectMaterials[idx].name);
          newA.appendChild(newContent);

          var insertLocation = document.getElementById("MatListBottom");
          parentLocation.insertBefore(newA, insertLocation);
        }
      }
    });
  }
  function materialClick(materialIdx) {
    selectedMaterial = objectMaterials[materialIdx];
    var header = document.getElementById("dropbtn");
    header.textContent = objectMaterials[materialIdx].name;
  }

  /* HTML JavaScript Extensions */
  //Sliding Nav Bar
  function openSideMenu() {
    document.getElementById('SettingsMenu').style.width = '250px';
    document.getElementById('SettingsMenu').style.fontSize = '100%';
    document.getElementById('SettingsMenu').style.opacity = '1';
    document.getElementById('SideBar').style.marginLeft = '250px';
    document.getElementById('burger').style.opacity = '0';
  }
  function closeSideMenu() {
    document.getElementById('SettingsMenu').style.width = '0px';
    document.getElementById('SettingsMenu').style.fontSize = '0px'
    document.getElementById('SettingsMenu').style.opacity = '0';
    document.getElementById('SideBar').style.marginLeft = '0px';
    document.getElementById('burger').style.opacity = '1';
  }

  //Export Functions from https://threejs.org/examples/misc_exporter_gltf.html
  //Not working correctly
  var link = document.createElement( 'a' );
  link.style.display = 'none';
  document.body.appendChild( link );

  function save( blob, filename ) {
    link.href = URL.createObjectURL( blob );
    link.download = filename;
    link.click();
  }
  function saveString( text, filename ) {
     save( new Blob( [ text ], { type: 'text/plain' } ), filename );
   }
  function saveArrayBuffer( buffer, filename ) {
     save( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );
   }

  /* jquery */
  $(function(){

    /* Picker */
      var bCanPreview = true; // can preview

      // create canvas and context objects
      var canvas = document.getElementById('picker');
      canvas.width /= 2;
      canvas.height = canvas.width;
      var ctx = canvas.getContext('2d');

      // drawing active image
      var image = new Image();

      // select desired colorwheel
      var imageSrc = 'Assets/ColourWheel.png';
      image.src = imageSrc;

      image.onload = function () {
          ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height); // draw the image on the canvas
      }

      $('#picker').mousemove(function(e) { // mouse move handler
          if (bCanPreview) {
              // get coordinates of current position
              var canvasOffset = $(canvas).offset();
              var canvasX = Math.floor(e.pageX - canvasOffset.left);
              var canvasY = Math.floor(e.pageY - canvasOffset.top);

              // get current pixel
              var imageData = ctx.getImageData(canvasX, canvasY, 1, 1);
              var pixel = imageData.data;

              // update preview color
              var pixelColor = "rgb("+pixel[0]+", "+pixel[1]+", "+pixel[2]+")";
              $('.preview').css('backgroundColor', pixelColor);

              // update controls
              $('#rVal').val(pixel[0]);
              $('#gVal').val(pixel[1]);
              $('#bVal').val(pixel[2]);
              $('#rgbVal').val(pixel[0]+','+pixel[1]+','+pixel[2]);

              var dColor = pixel[2] + 256 * pixel[1] + 65536 * pixel[0];
              $('#hexVal').val('#' + ('0000' + dColor.toString(16)).substr(-6));
              $('#hexVal').css('backgroundColor', pixelColor);

              if(selectedMaterial){
                selectedMaterial.color = new THREE.Color(pixelColor);
              }
          }
      });

      /* Misc */
      $('#picker').click(function(e) { bCanPreview = !bCanPreview; });
      $('#SideBar').mouseover(function(e) { raycastEnabled = false; });
      $('#SideBar').mouseout(function(e) { raycastEnabled = true; });
      $('#icons').mouseover(function(e) { raycastEnabled = false; });
      $('#icons').mouseout(function(e) { raycastEnabled = true; });
      $('#burgerHeader').mouseover(function(e) { raycastEnabled = false; });
      $('#burgerHeader').mouseout(function(e) { raycastEnabled = true; });



  });
  </script>
</body>
</html>
