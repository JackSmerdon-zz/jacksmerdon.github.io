<!DOCTYPE html>
<html>

<head>
  <title>3D Level Design Tool</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="style.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
</head>
<body>
  <!-- Top Bar -->
  <div class="icons">
    <img src='Assets/Icons/Burger.png' onmouseover="this.src='Assets/Icons/BurgerHover.png';" onmouseout="this.src='Assets/Icons/Burger.png';" href="#" onclick="openSideMenu()" alt="T" id="burger"/>
    <img src='Assets/Icons/Snap.png' onmouseover="this.src='Assets/Icons/SnapHover.png';" onmouseout="this.src='Assets/Icons/Snap.png';" href="#" onclick="toggleSnap()" alt="T" id="icon" />
    <img src='Assets/Icons/Scale.png' onmouseover="this.src='Assets/Icons/ScaleHover.png';" onmouseout="this.src='Assets/Icons/Scale.png';" href="#" onclick="toggleTransform('scale')" alt="S" id="icon" />
    <img src='Assets/Icons/Rotate.png' onmouseover="this.src='Assets/Icons/RotateHover.png';" onmouseout="this.src='Assets/Icons/Rotate.png';" href="#" onclick="toggleTransform('rotate')" alt="R" id="icon" />
    <img src='Assets/Icons/Translate.png' onmouseover="this.src='Assets/Icons/TranslateHover.png';" onmouseout="this.src='Assets/Icons/Translate.png';" href="#" onclick="toggleTransform('translate')" alt="T" id="icon" />
  </div>

  <!-- Left Side Navigation Menu -->
  <div id="SideBar">
    <div id="SettingsMenu">
      <ul class="SideBarUl">
        <!-- Header -->
        <li href="#" class="header">
          <div>
            <h1>3D Level Design Tool
              <h2>Jack Smerdon</h2>
            </h1>
          </div>
          <a = href="#" onclick="closeSideMenu()">X</a>
        </li>

        <!-- Camera Settings -->
        <li class="camera"><a>Camera</a>
          <ul class="cameraDark">
            <li><a>Auto Rotate
              <label class="switch">
                <input type="checkbox"  onclick="toggleAutoRotate()">
                <span class="slider round"></span>
              </label></a>
            </li>
            <li><a>Rotation Lock
              <label class="switch">
                <input type="checkbox"  onclick="toggleRotationLock()" checked>
                <span class="slider round"></span>
              </label></a>
            </li>
            <li><a>Standard Views:</a>
              <ul>
                <a href="#" onclick="camView('Front')">Front</a>
                <a href="#" onclick="camView('Side')">Side</a>
                <a href="#" onclick="camView('Top')">Top</a>
              </ul>
            </li>
            <li><a href="#" onclick="toggleCamReset()">Reset</a></li>
          </ul>
        </li>

        <!-- Model Settings -->
        <li class="models"><a>Models</a>
          <ul class="modelsDark">
            <li><a href="#">Load New Model:</a>
              <ul>
                <a>Model:</a>
                <input type="file" id="NewModel" accept=".obj">
                <a>Material:</a>
                <input type="file" id="NewMaterial" accept=".mtl">
                <a>Texture:</a>
                <input type="file" id="NewTexture" accept=".png">

                <a href='#' onClick="loadNewModel()">Load Model</a>
              </ul>
            </li>
            <li><a>Objects in Scene:</a>
              <ul id="Objects">
                <li id="ObjectsBottom"></li>
              </ul>
            </li>
          </ul>
        </li>

        <!-- Prefab Settings -->
        <li class="prefab"><a>Prefabs</a>
          <ul class="prefabDark">
            <li><a>Generate Primative:</a>
              <ul>
                <a href="#" onclick="spawnBox()">Box</a>
                <a href="#" onclick="spawnCylinder()">Cylinder</a>
                <a href="#" onclick="spawnPlane()">Plane</a>
                <a href="#" onclick="spawnSphere()">Sphere</a>
              </ul>
            </li>
            <li><a>Other:</a>
              <ul>
                <a href="#" onclick="loadFromFile('Monkey')">Monkey</a>
                <a href="#" onclick="loadFromFile('Donut')">Donut</a>
                <a href="#" onclick="loadFromFile('Planet')">Planet</a>
              </ul>
            </li>
            <li><a>Water
              <label class="switch">
                <input type="checkbox" onclick="toggleWater()">
                <span class="slider round"></span>
              </label></a>
            </li>
            <li><a>Grid
              <label class="switch">
                <input type="checkbox" onclick="toggleGrid()"checked>
                <span class="slider round"></span>
              </label></a>
            </li>

          </ul>
        </li>

        <!-- Lighting Settings -->
        <li class="lighting"><a>Lighting</a>
          <ul class="lightingDark">
            <li><a>Existing Lights:</a>
              <ul id="Lights">
              <ul id="LightsBottom"></ul>
            </ul>
            <li><a>Spawn:</a>
              <ul>
                <a href="#" onclick="addLight('Directional')">Directional</a>
                <a href="#" onclick="addLight('Ambient')">Ambient</a>
                <a href="#" onclick="addLight('Point')">Point</a>
                <a href="#" onclick="addLight('Spot')">Spot</a>
              </ul>
            </li>
            <li><a>Preset:</a>
              <ul>
                <a href="#" onclick="lightingPreset('Bright')">Bright</a>
                <a href="#" onclick="lightingPreset('Sunset')">Sunset</a>
                <a href="#" onclick="lightingPreset('Moonlight')">Moonlight</a>
                <a href="#" onclick="lightingPreset('Spotlight')">Spotlight</a>
                <a href="#" onclick="lightingPreset('Moody')">Moody</a>
              </ul>
            </li>
          </ul>
        </li>

        <!-- Rendering Settings -->
        <li class="rendering"><a>Rendering</a>
          <ul class="renderingDark">
            <li><a>Wireframes
              <label class="switch">
                <input type="checkbox" id="wireframeSwitch" onclick="toggleRendering('Wireframes')">
                <span class="slider round"></span>
              </label></a>
            </li>
            <li><a>Shadows
              <label class="switch">
                <input type="checkbox" id="shadowSwitch" onclick="toggleRendering('Shadows')">
                <span class="slider round"></span>
              </label></a>
            </li>
          </ul>
        </li>

        <!-- Skybox Settings -->
        <li class="skybox"><a>Skybox</a>
          <ul class="skyboxDark">
            <li><a>Textures:</a>
              <ul>
                <a>Front:</a>
                <input type="file" id="NewFrontIMG" accept="image/*">

                <a>Back:</a>
                <input type="file" id="NewBackIMG" accept="image/*">

                <a>Up:</a>
                <input type="file" id="NewUpIMG" accept="image/*">

                <a>Down:</a>
                <input type="file" id="NewDownIMG" accept="image/*">

                <a>Right:</a>
                <input type="file" id="NewRightIMG" accept="image/*">

                <a>Left:</a>
                <input type="file" id="NewLeftIMG" accept="image/*">
                <a href="#" onclick="updateSkybox()">Load Skybox</a>
              </ul>
            </li>

            <li><a>Help:</a>
              <ul>
                <a href="#" onclick="loadSkybox('Default')">Reset to Default</a>
                <a href="#" onclick="loadSkybox('Helper')">Helper Textures</a>
              </ul>
            </li>
            <li><a>Sample:</a>
              <ul>
                <a href="#" onclick="loadSkybox('Jungle')">Jungle</a>
                <a href="#" onclick="loadSkybox('Sky')">Sky</a>
                <a href="#" onclick="loadSkybox('Space')">Space</a>
              </ul>
            </li>
            <li><a>Settings:</a>
              <ul>
                <a>Size</a>
                <div class="slidecontainer">
                  <input type="range" min="10" max="10000" value="8000" class="rangeSlider" id="skybox" step="1">
                </div>
              </ul>
            </li>
          </ul>
        </li>

        <!-- Scene Settings -->
        <li class="scene"><a>Scene</a>
          <ul class="sceneDark">
            <li><a>Settings:</a>
              <ul>
                <a>Fog</a>
                <div class="slidecontainer">
                  <input type="range" min="0" max="0.085" value="0" class="rangeSlider" id="fog" step="0.0001">
                </div>
                <a>Grid Size</a>
                <div class="slidecontainer">
                  <input type="range" min="2" max="499" value="50" class="rangeSlider" id="grid" step="2">
                  <output  id="range_weight_disp"></output>
                </div>
                <a>Water Size</a>
                <div class="slidecontainer">
                  <input type="range" min="2" max="9500" value="0" class="rangeSlider" id="water" step="2">
                </div>
              </ul>
            </li>
            <li><a>Sample Scenes:</a>
              <ul>
                <a href="#" onclick="loadSampleScene()">Jungle</a>
                <a href="#" onclick="loadSampleScene()">Island</a>
                <a href="#" onclick="loadSampleScene()">Space</a>
              </ul>
            </li>
            <li><a>Load Scene:</a>
              <ul>
                <input type="file" id="NewGLTF" accept=".gltf" style="font-size: 10px;">
                <a href="#" onclick="loadScene()">Load Scene</a>
              </ul>
            </li>
            <li><a>Save Scene:</a>
              <ul>
                  <a href="#" onclick="saveScene()">Save as GLTF</a>``
              </ul>
            </li>
            <li><a href="#" onclick="clearScene()">New Scene</a></li>
          </ul>
        </li>

        <!-- Properties -->
        <li class="properties"><a>Properties</a>
          <ul class="ColourPicker">
              <h1 id="header">Select Object</h1>

              <canvas id="ColourWheel"></canvas>

              <div class="dropdown">
                <button id="dropbtn">Select Material</button>
                <div class="dropdown-content">
                  <ul id="MatListTop">
                    <ul id="MatListBottom"></ul>
                  </ul>
                </div>
              </div>

              <div class="rgbValues">
                <div><label>R</label> <input type="text" id="rVal" /></div>
                <div><label>G</label> <input type="text" id="gVal" /></div>
                <div><label>B</label> <input type="text" id="bVal" /></div>
                <div><label>HEX</label> <input type="text" id="hexVal" /></div>
              </div>

              <a id="materialSliderTitle">Intensity</a>
              <div class="slidecontainer">
                <input type="range" min="0" max="1" value="1" class="rangeSlider" id="material" step="0.1">
              </div>

              <a href="#" onclick="removeObject()">Remove Object</a>
          </ul>
        </li>
      </ul>
    </div>
  </div>

  <!-- Includes -->
  <script src="Imports/three.js"></script>
  <script src="Imports/Detector.js"></script>
  <script src="Imports/TransformControls.js"></script>
  <script src="Imports/OrbitControls.js"></script>
  <script src="Imports/OBJLoader.js"></script>
  <script src="Imports/MTLLoader.js"></script>
  <script src="Imports/GLTFLoader.js"></script>
  <script src="Imports/GLTFExporter.js"></script>
  <script src="Imports/Water.js"></script>
  <script src="Imports/jquery.js"></script>

  <!-- Program -->
  <div class="container"></div>
  <script>

  //Displays message to the user if webGL is not supported in the browser.
  if (!Detector.webgl) { Detector.addGetWebGLMessage(); }

  //Essentials
  var container = document.createElement('div');
  document.getElementsByClassName("container")[0].appendChild(container);
  var scene = new THREE.Scene();
  var camera, control, orbit, renderer;
  var skybox, grid, water;

  //Grid snapping bool
  var snap = false;

  //Raycasting
  var Raycasts = [];
  var raycastCount = 0;
  var raycaster = new THREE.Raycaster();
  var mouse = new THREE.Vector2();
  var raycastEnabled = true;

  //Object Selection & Modification
  var selectedObject;
  var objectMaterials = [];
  var selectedMaterial;
  var objectType;

  //Light Selection & Modification
  var Lights = [];
  var lightCount = 0;
  var containsDirectional = false;

  //Rendering
  var wireframes = false;
  var shadows = false;

  //Scene Settings
  var gridSize = 50;
  var waterSize = 50;
  var skyboxSize = new THREE.Vector3(100,100,100);

  init();
  animate();

  /* Utils */
  function toRadians (angle) {
    return angle * (Math.PI / 180);
  }

  /* Init */
  function animate() {
    requestAnimationFrame(animate);
    update();
    render();
  }
  function render() {
    //Passes time to water shader to make it 'move'
    if(scene.getObjectByName("Water"))
    {
        water.material.uniforms[ "time" ].value += 1.0 / 600.0;
    }

    //Renders the scene
    renderer.render(scene, camera);

    // Stops user from refreshing the page
    window.onbeforeunload = function() {
        return "Leaving the page without saving will result in loss of data. Do you wish to continue?";
    }
  }
  function init() {
    //Fixes bug where side menu is distorted on first load
    closeSideMenu();

    //Initialises camera
    setupCamera(0, 10, 25, 0.1, 25000);
    setupRenderer();
    setupOrbitControls();
    setupTransformControls();

    spawnGrid();
    toggleGrid()
    spawnWater();
    toggleWater();

    //Events
    window.addEventListener('resize', onWindowResize, false);
    window.addEventListener( 'mousedown',onDocumentMouseDown, false );
    window.addEventListener( 'mousemove', onMouseMove, false );
    window.addEventListener('touchend', onDocumentTouchEnd, false);

    //To be replaced by GLTF load

    updateList("Objects", Raycasts);
    updateList("Lights", Lights);
    lightingPreset("Bright");

    //Logs scene hierarchy to console for debugging
    //console.log("Default Scene Hierarchy", scene);
  }
  function update() {

    //Required for auto-rotation button
    orbit.update();

    //Detects if a new object has been added to scene
    if(Raycasts.length != raycastCount)
    {
      //Updates counter
      raycastCount = Raycasts.length;
      //Updates GUI
      updateList("Objects", Raycasts);

      //Calls rendering functions to sync new object with scene
      if(wireframes){
        wireframes = false;
        toggleRendering('Wireframes');
      }
      if(shadows){
        shadows = false;
        toggleRendering('Shadows');
      }
    }

    //Detects if new light has been added to the scene
    if(Lights.length != lightCount)
    {
      //Updates light counter
      lightCount = Lights.length;
      //Updates GUI
      updateList("Lights", Lights);
    }

    //Detects if a new object has been clicked on by the user
    //Or if the object has been de-selected
    if (selectedObject != control.object)
    {
      //Gets header (properties menu) from HTML
      var header = document.getElementById("header");
      //Updates selection validation
      selectedObject = control.object;

      //If there is a new object selected:
      if(selectedObject)
      {
        //Update properties title
        header.textContent = selectedObject.name;
        //Load properties into GUI
        updateProperties(selectedObject);
      }
      //If there is no longer an object selected:
      else {
        //Resets title
        header.textContent = "Select Object";
      }

      //Gets dropdown button from HTML
      var btn = document.getElementById("dropbtn");
      //Resets button
      btn.textContent = "Select Material";
      //Resets material selection validation
      selectedMaterial = null;
    }

    //Gets grid size slider from HTML
    var gridSlider = document.getElementById("grid");
    //Detects change in slider and calls function:
    gridSlider.oninput = function () {
      //Removes grid from scene, updates size, spawns and adds new grid
      toggleGrid();
      gridSize = this.value;
      grid = null;
      spawnGrid();
      toggleGrid();
    }

    //Gets fog density slider from HTML
    var fogSlider = document.getElementById("fog");
    //Detects change in slider and calls function:
    fogSlider.oninput = function () {
      //Updates fog density based on slider value
      scene.fog = new THREE.FogExp2(0xffffff, this.value);
    }

    //Gets skybox size slider from HTML
    var skyboxSlider = document.getElementById("skybox");
    //Detects change in slider and calls function:
    skyboxSlider.oninput = function () {
      //Updates size variable
      skyboxSize = this.value;
      //Spawns new skybox with updated size
      updateSkyboxSize();
    }

    //Gets water size slider from HTML
    var waterSlider = document.getElementById("water");
    //Detects change in slider and calls function:
    waterSlider.oninput = function () {
      //Updates size variable
      waterSize = this.value;
      //Spawns new skybox with updated size
      spawnWater();
    }
  }

  /* Camera Setup */
  function setupCamera(x, y, z, near, far) {
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, near, far);

    //Update position
    camera.position.x = x;
    camera.position.y = y;
    camera.position.z = z;
  }
  function setupRenderer() {
    renderer = new THREE.WebGLRenderer({antialias: true});

    //Update size to fit device
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    //Sets the background to a dark grey
    renderer.setClearColor(new THREE.Color("hsl(0, 0%, 10%)"));

    //Adds the renderer to the HTML
    container.appendChild(renderer.domElement);

    //Enable shadows
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  }
  function setupOrbitControls(){
    orbit = new THREE.OrbitControls(camera, renderer.domElement);

    //Smooths movement when panning by adding 'weight'
    orbit.enableDamping = true;
    orbit.dampingFactor = 0.08;
    orbit.keyPanSpeed = 5;
    orbit.panSpeed = 0.05;

    //Enables zoom and sets how far you can zoom in and out
    orbit.enableZoom = true;
    orbit.minDistance = 3;
    orbit.maxDistance = camera.far;

    //Disables auto-rotate as default (Can be toggled in GUI)
    orbit.autoRotate = false;
    orbit.autoRotateSpeed = -0.1;

    //Slows rotation to improve user experience and precision
    orbit.rotateSpeed = 0.1;

    //Fixes rotation to prevent looking from underneath (Can be toggled)
    orbit.maxPolarAngle = 1.5;

    //Applies changes
		orbit.update();

    //Calls the render function if a change is detected
		orbit.addEventListener( 'change', render );
  }
  function setupTransformControls() {
    control = new THREE.TransformControls( camera, renderer.domElement );

    //Calls render function if change is detected
    control.addEventListener( 'change', render );

    //Disables orbit controls and switching selected object when transforming
    control.addEventListener( 'dragging-changed', function ( event ) {
      orbit.enabled = !event.value;
      raycastEnabled = !event.value;
    } );
  }

  /* Events */
  function onWindowResize() {
    //Updates camera and rendered with new window size
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
  function onMouseMove( event ) {
	  //Calculate mouse position
	  mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
  }
  function onDocumentTouchEnd(event) {
    //Updates mouse position with touch input
    mouse.x = (event.changedTouches[0].clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.changedTouches[0].clientY / window.innerHeight) * 2 + 1;

    //Fires mousedown as all touches end with a click, unlike mouse movement
    onDocumentMouseDown();
  }
  function onDocumentMouseDown( e ) {
    //Updates raycaster with new mouse position
    raycaster.setFromCamera( mouse, camera );
    //Gets a list of all objects which intersect with the raycast
    var intersects = raycaster.intersectObjects( Raycasts, true );
    //If there are no objects in the ray:
    if(intersects.length === 0)
    {
      //Disabled when interacting with GUI
      if(raycastEnabled)
      {
        //Detach and remove the transform controls from the scene
        control.detach();
        scene.remove( control );
      }
    }
    else if(raycastEnabled)
    {
      //Checks all elements of array of selectable objects
      for (var i = 0; i < Raycasts.length; i++) {
        //Imported models are in a group
        //Parent is in Raycasts but child is seen by raycaster
        if (intersects[0].object.parent === Raycasts[ i ]) {
          //Attaches transform controls
          control.attach( Raycasts[i] );
          scene.add( control );
        }
        else if (intersects[0].object === Raycasts[ i ]) {
          control.attach( Raycasts[i] );
          scene.add( control );
        }
      }
    }
  }

  /* Top Bar Controls */
  function toggleTransform(type) {
    //Updates to translation, rotation or scale based on string 'type'
    control.setMode( type );
  }
  function toggleSnap() {
    //Flips the boolean
    snap = !snap;
    if(snap) {
      //Calculates an appropriate snap size based on the size of the grid
      control.setTranslationSnap( (gridSize/2) / (gridSize/2 + 1) );
      //Sets the rotation snap to 15 degrees
      control.setRotationSnap( THREE.Math.degToRad( 15 ) );
    }
    else {
      //Turns off snapping of translation & rotation
      control.setTranslationSnap( null );
      control.setRotationSnap( null );
    }
  }

  /* Side Bar Controls */
  //Camera
  function toggleAutoRotate () {
    //Flips the auto rotation bool on the orbit controls
    orbit.autoRotate = !orbit.autoRotate;
  }
  function toggleRotationLock() {
    if (orbit.maxPolarAngle === 1.5)
    {
      //Default value for no rotation limit
      orbit.maxPolarAngle = Math.PI;
    }
    else {
      //Stops the rotation at the level of the grid
      orbit.maxPolarAngle = 1.5;
    }
    //Updates the controls
    orbit.update();
  }
  function toggleCamReset () {
    //Resets the camera to its original position
    orbit.reset();
  }
  function camView (view){
    //Updates the cameras position to desired view
    switch (view)
    {
      case "Top":
      {
        camera.position.x = 0;
        camera.position.y = 25;
        camera.position.z = 0;
        break;
      }
      case "Side":
      {
        camera.position.x = 25;
        camera.position.y = 10;
        camera.position.z = 0;
        break;
      }
      case "Front":
      {
        camera.position.x = 0;
        camera.position.y = 10;
        camera.position.z = 25;
        break;
      }
    }
  }
  //Models
  function loadNewModel() {
    //Assume the model doesn't have textures
    var loadTex = false;

    //Locates files from input boxes in the HTML that the user has uploaded
    var newModel = document.getElementById('NewModel').files[0];
    var newMat = document.getElementById('NewMaterial').files[0];
    var newTex = document.getElementById('NewTexture').files[0];

    //Ensures there is a model and material present or errors will occur
    if(typeof document.getElementById('NewModel').files[0] !== 'undefined' && typeof document.getElementById('NewMaterial').files[0] !== 'undefined')
    {
      //Creates a URL so that the JavaScript is able to interact with the blob
      var OBJFile = URL.createObjectURL( newModel );
      var MTLFile = URL.createObjectURL( newMat );

      //Loading manager to help with texture loading issue
      var manager = new THREE.LoadingManager();

      //If the user has uploaded a texture:
      if(typeof document.getElementById('NewTexture').files[0] !== 'undefined')
      {
        //Creates URL
        var JPGFile = URL.createObjectURL( newTex );

        //Fixes URL location
        //Material contains path for texture which overwrites newTex URL, this fixes it
        manager.setURLModifier (function ( url ) {
          url = JPGFile;
          return url;
        });

        loadTex = true;
      }

      //Creates instances of loaders required. The material loader uses the manager to fix this ^^ issue
      var objLoader = new THREE.OBJLoader();
      var mtlLoader = new THREE.MTLLoader(manager);
      var texLoader = new THREE.TextureLoader();

      mtlLoader.load(MTLFile, function (materials) {
        objLoader.setMaterials(materials)
        objLoader.load(OBJFile, function (object) {
          if (loadTex)
          {
            //Loads the texture
            var texture = texLoader.load(JPGFile);
            object.traverse(function (child) {
              if (child instanceof THREE.Mesh) {
                //Maps the texture to each mesh instance
                child.material.map = texture;
              }
            });
          }
          //Adds the object to the scene
          scene.add(object);
          //Adds it to Raycasts so it can be manipulated
          Raycasts.push(object);
        });
      });
    }
  }
  function updateList(listToUpdate, container){

    //Clears the list from the HTML
    var list = document.getElementById(listToUpdate);
    while (list.firstChild) {
      list.removeChild(list.firstChild);
    }

    //For each element in Lights or Raycasts (container)
    container.forEach(function(element) {
      //Create new list item
      var newLi = document.createElement("li");
      newLi.setAttribute('id', element.name);

      //Create new hyperlink item
      var newA = document.createElement("a");
      newA.setAttribute('href', "#");
      //Assign function call to hyperlink
      newA.setAttribute('onclick', "select" + listToUpdate + "('" + element.name + "')");

      //Create content to add the name of the object in the GUI
      var newContent = document.createTextNode(element.name);

      //Append the created elements to form hierarchy
      newA.appendChild(newContent);
      newLi.appendChild(newA);

      //Appends the created HTML element to the end of the list
      var parentLocation = document.getElementById(listToUpdate);
      var insertLocation = document.getElementById(listToUpdate + "Bottom");
      parentLocation.insertBefore(newA, insertLocation);
    });

  }
  function selectObjects(item){
    //Iterates through all selectable objects
    for (var i = 0; i < Raycasts.length; i++) {
      //Selects item based on name
      if (item === Raycasts[ i ].name) {
        //Attaches transform to the selected object
        control.attach( Raycasts[i] );
        scene.add( control );
        //Exits the loop
        i = Raycasts.length;
      }
    }
  }
  //Prefabs
  function spawnBox() {
    //Create geometry and material to form a mesh
    var geometry = new THREE.BoxGeometry( 5, 5, 5 );
    var material = new THREE.MeshPhongMaterial( {color: 0xaaaaaa} );
    var cube = new THREE.Mesh( geometry, material );
    //Enable shadows
    cube.castShadow = true;
    cube.receiveShadow = true;
    //Rename it for GUI readability
    cube.name = "Cube";
    //Add the cube to the scene and to list of selectable objects
    scene.add(cube);
    Raycasts.push(cube);
  }
  function spawnCylinder() {
    //Create geometry and material to form a mesh
    var geometry = new THREE.CylinderGeometry( 5, 5, 20, 32 );
    var material = new THREE.MeshPhongMaterial( {color: 0xaaaaaa} );
    var cylinder = new THREE.Mesh( geometry, material );
    //Enable shadows
    cylinder.castShadow = true;
    cylinder.receiveShadow = true;
    //Rename for GUI readability
    cylinder.name = "Cylinder";
    //Add the cylinder to the scene and to list of selectable objects
    scene.add( cylinder );
    Raycasts.push(cylinder);
  }
  function spawnPlane() {
    //Create geometry and material to form a mesh
    var planeGeometry = new THREE.PlaneGeometry( 50, 50, 1, 1 );
    var planeMaterial = new THREE.MeshPhongMaterial( {color: 0x707070, side: THREE.DoubleSide} );
    var plane = new THREE.Mesh( planeGeometry, planeMaterial );
    //Rotate from vertical to horizontal
    plane.rotation.x = toRadians(90);
    //Enable shadows
    plane.receiveShadow = true;
    //Rename for GUI readability
    plane.name = "Plane";
    //Add to the scene and to list of selectable objects
    scene.add( plane );
    Raycasts.push(plane);
  }
  function spawnSphere() {
    //Create geometry and material to form a mesh
    var geometry = new THREE.SphereGeometry( 5, 32, 32 );
    var material = new THREE.MeshPhongMaterial( {color: 0xaaaaaa} );
    var sphere = new THREE.Mesh( geometry, material );
    //Enable shadows
    sphere.castShadow = true;
    sphere.receiveShadow = true;
    //Rename for GUI readability
    sphere.name = "Sphere";
    //Add to the scene and to list of selectable objects
    scene.add( sphere );
    Raycasts.push(sphere);
  }
  function loadFromFile(name) {
    //Instantiate loaders
    var mtlLoader = new THREE.MTLLoader();
    var objLoader = new THREE.OBJLoader();
    //Set the path for loading files
    mtlLoader.setPath('Assets/Models/');
    objLoader.setPath('Assets/Models/');

    mtlLoader.load( (name + '.mtl'), function( materials )
    {
      objLoader.setMaterials( materials );
      objLoader.load( (name + '.obj'), function ( object ) {
        //Traverses the loaded object and enables shadows per mesh
        object.traverse( function ( child ) {
          if (child instanceof THREE.Mesh)
          {
              child.castShadow = true;
          }
        });
        //Moves the object closer to the grid
        object.translateY(1.5);
        //Renames object for readability
        object.name = name;
        //Add object to scene and selectable objects
        scene.add(object);
        Raycasts.push(object);
      } );
    } );
  }
  function spawnGrid() {
    //Create grid instance in global variable
    grid = new THREE.GridHelper(gridSize, gridSize/2 + 1);
    //Rename for GUI readability
    grid.name = "Grid";
  }
  function toggleGrid() {
    //Removes or adds the grid based on if it is present in the scene
    if(scene.getObjectByName("Grid"))
    {
      scene.remove(grid);
    }
    else {
      scene.add(grid);
    }
  }
  function spawnWater() {
    //Removes the water if there is some present in the scene already
    if(scene.getObjectByName("Water"))
    {
      scene.remove(water);
    }

    //Generates a new plane using the size set by the user (Default is 50)
    var waterGeometry = new THREE.PlaneBufferGeometry( waterSize, waterSize );

    water = new THREE.Water(
      waterGeometry,
      {
        //Load in the normal map from file
        textureWidth: 512,
        textureHeight: 512,
        waterNormals: new THREE.TextureLoader().load( 'Assets/Water.png', function ( texture ) {
        //Apply wrapping for realistic effect
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        } ),
        //Transparancy
        alpha: 0.85,
        //Static values given, could be done dynamically for better effect
        sunDirection: new THREE.Vector3(10,10,10).normalize(),
        sunColor: 0xffffff,
        waterColor: 0x256d7b,
        distortionScale: 20,
        fog: false
      }
    );
    //Rotates so that it lies horizontally
    water.rotation.x = toRadians(-90);
    //Raised above the grid to prevent unwanted reflection artifacts
    water.position.y = 0.05;
    //Renamed to be found by toggle function
    water.name = "Water";
    //Enable transparency
    water.material.transparent = true;
    //Add to the scene
    scene.add(water);
  }
  function toggleWater() {
    //Checks to see if the scene already contrains water
    if(scene.getObjectByName("Water"))
    {
      //Removes transform controls
      control.detach();
      scene.remove( control );
      //Removes the water
      scene.remove(water);
      //Locates the element in the Raycasts array
      for( var i = 0; i < Raycasts.length; i++){
       if ( Raycasts[i].name === "Water") {
         //Removes water from Raycasts
         Raycasts.splice(i, 1);
       }
      }
    }
    else {
      //Add the water to the scene and selectable objects
      scene.add(water);
      Raycasts.push(water);
    }
  }
  //Lighting
  function addLight (type) {
    var light;
    //Type is passed in from HTML button press to determine type
    switch (type)
    {
      case "Ambient":
      {
        //Create new instance of ambient light
        light = new THREE.AmbientLight(0xffffff, 1.0);
        //Default is 0.5 intensity, can be between 0 and 2
        light.intensity = 0.5;
        //Renamed for GUI readability
        light.name = "Ambient Light";
        //Added to the scene and array of lights
        scene.add(light);
        Lights.push(light);
        break;
      }
      case "Directional":
      {
        if(!containsDirectional)
        {
          //Create new instance of directional light
          light = new THREE.DirectionalLight(0xffffff, 1)
          //Renamed for GUI readability
          light.name = "Directional Light";
          //Default position is directly above
          light.position.set(0,10,0);

          //Create a target of the origin which the light is directed at
          var target = new THREE.Object3D();
          target.position.set(0,0,0);
          light.target = target;

          //Setup shadows
          light.shadow.camera.left = -1000;
          light.shadow.camera.right = 1000;
          light.shadow.camera.top = 1000;
          light.shadow.camera.bottom = -1000;
          light.shadow.camera.near = 10;
          light.shadow.camera.far = 500;
          light.shadow.mapSize.width = 8192;
          light.shadow.mapSize.height = 8192;

          //Disable shadows as weaker systems can't handle them
          light.castShadow = false;
          //Boolean to ensure only one directional light is in the scene
          containsDirectional = true;
          //Adds the light to the scene and array
          scene.add(light);
          Lights.push(light);
        }
        break;
      }

      case "Point":
      {
        //Creates new point light instance
        light = new THREE.PointLight( 0xff0000, 1, 100 );
        //Sets default position to be just above origin
        light.position.set( 0, 3, 0 );
        //Renamed for readability
        light.name = "Point Light";
        //Added to scene and light array
        scene.add(light);
        Lights.push(light);
        break;
      }
      case "Spot":
      {
        //Create new spot light instance
        light = new THREE.SpotLight(0xffffff, 1, 10, 0.3);
        //Positioned central above origin
        light.position.set( 0, 3, 0 );
        //Renamed for GUI readability
        light.name = "Spot Light";
        //Added to scene and light array
        var spotLightHelper = new THREE.SpotLightHelper( light );
        scene.add( spotLightHelper );
        scene.add(light);
        Lights.push(light);
      }
    }
  }
  function selectLights(item){
    //Loops through array to locate selected object based on name
    for (var i = 0; i < Lights.length; i++) {
      if (item === Lights[ i ].name) {
        //Attaches transfrom controls to object and exits loop
        control.attach( Lights[i] );
        scene.add( control );
        i = Lights.length;
      }
    }
  }
  function lightingPreset(type){
    //Removes all light from the scene
    for(var i = 0; i < Lights.length; i++)
    {
      scene.remove(Lights[i]);
    }

    //Clears the light array and resets bool
    Lights = [];
    containsDirectional = false;

    //Turns on shadows if required
    var shadowHelp = false;
    if(shadows)
    {
      toggleRendering("Shadows");
      shadowHelp = true;
    }

    //Preset scenes with directional and ambient lights
    //of varying colour and intensity
    switch(type)
    {
      case "Bright":
      {
        addLight("Ambient");
        Lights[0].intensity = 0.8;

        addLight("Directional");
        Lights[1].position.set (100,100,100);
        break;
      }
      case "Sunset":
      {
        addLight("Ambient")
        Lights[0].intensity = 0.25;
        Lights[0].colour = new THREE.Color(0x362D59);

        addLight("Directional");
        Lights[1].position.set (0,0,500);
        Lights[1].color = new THREE.Color(0xFF4400);
        Lights[1].intensity = 2;
        break;
      }
      case "Moonlight":
      {
        addLight("Ambient")
        Lights[0].intensity = 0.1;
        Lights[0].colour = new THREE.Color(0x362D59);

        addLight("Directional");
        Lights[1].position.set (100,500,100);
        Lights[1].color = new THREE.Color(0xFFFFBB);
        Lights[1].intensity = 0.6;
        break;
      }
      case "Spotlight":
      {
        addLight("Directional");
        Lights[0].position.set (100,500,100);
        Lights[0].color = new THREE.Color(0xFFFFFF);
        Lights[0].intensity = 2;
        break;
      }
      case "Moody":
      {
        addLight("Ambient");
        Lights[0].color = new THREE.Color(0xFF0000);
        Lights[0].intensity = 0.5;

        addLight("Directional");
        Lights[1].position.set (0,500,0);
        Lights[1].color = new THREE.Color(0xF500FF);
        Lights[1].intensity = 0.4;
        break;
      }
      case "Jungle":
      {
        addLight("Ambient");
        Lights[0].intensity = 0.8;

        addLight("Directional");
        Lights[1].position.set (0,10,-10);
        Lights[1].color = new THREE.Color(0xCAFFE1);
        break;
      }
      case "Sky":
      {
        addLight("Ambient");
        Lights[0].intensity = 0.8;

        addLight("Directional");
        Lights[1].position.set (10,10,-10);
        Lights[1].color = new THREE.Color(0xFFFFBB);
        break;
      }
      case "Space":
      {
        addLight("Ambient");
        Lights[0].intensity = 0.1;

        addLight("Directional");
        Lights[1].position.set (-20,0,-100);
        Lights[1].color = new THREE.Color(0xFFFFBB);
        Lights[1].intensity = 2;
        break;
      }
    }

    //Calls the function to update the GUI
    updateList("Lights", Lights);
    //Toggles shadows if required
    if(shadowHelp)
    {
      toggleRendering("Shadows");
    }
  }
  //Rendering
  function toggleRendering(type) {
    if (type == "Shadows")
    {
      //Flips identifier boolean
      shadows = !shadows;
      //Loops through array to find the directional light
      for(var i = 0; i < Lights.length; i++)
      {
        if(Lights[i].type == "DirectionalLight")
        {
          //Updates shadows on the directional light
          Lights[i].castShadow = shadows;
          //Exits the loop
          i = Lights.length;
        }
      }
    }
    else {
      //Flips wireframe boolean
      wireframes = !wireframes;
      //Iterates through selectable objects
      for (var i = 0; i < Raycasts.length; i++)
      {
        Raycasts[i].traverse( function ( child ) {
          //Adds wireframe to any mesh that isnt a plane
          if (child instanceof THREE.Mesh && child.name != "Plane")
          {
            //For multi-material models
            if (child.material.length > 0)
            {
              for(var i = 0; i < child.material.length; i++)
              {
                child.material[i].wireframe = wireframes;
              }
            }
            //For primatives
            else {
              child.material.wireframe = wireframes;
            }
          }
        });
      }
    }
  }
  //Skybox
  function updateSkybox(){
    //Removes current skybox from the scene
    scene.remove(skybox);

    //Retrieves user uploaded files from HTML
    var front = document.getElementById('NewFrontIMG').files[0];
    var back = document.getElementById('NewBackIMG').files[0];
    var up = document.getElementById('NewUpIMG').files[0];
    var down = document.getElementById('NewDownIMG').files[0];
    var right = document.getElementById('NewRightIMG').files[0];
    var left = document.getElementById('NewLeftIMG').files[0];

    //Generates URL for each blob
    var frontURL = URL.createObjectURL( front );
    var backURL = URL.createObjectURL( back );
    var upURL = URL.createObjectURL( up );
    var downURL = URL.createObjectURL( down );
    var rightURL = URL.createObjectURL( right );
    var leftURL = URL.createObjectURL( left );

    //Create a cube for the skybox
    var skyboxGeometry = new THREE.CubeGeometry(skyboxSize);
    //Create an array of materials which are mapped with the user files
    skyboxMaterials =
    [
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load(frontURL), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load(backURL), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load(upURL), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load(downURL), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load(rightURL), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load(leftURL), side: THREE.DoubleSide})
    ];

    //Instantiate a mesh with the new geometry and material array to replace current skybox
    skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
    //Add the new skybox to the scene
    scene.add(skybox);
  }
  function loadSkybox(name) {
    //Loads relevant lighting preset
    lightingPreset(name);
    //Removes current skybox
    scene.remove(skybox);
    //Create new cube geometry
    var skyboxGeometry = new THREE.CubeGeometry(10000, 10000, 10000);
    //Load from file using paramater as directory name to load desired files
    var skyboxMaterials =
    [
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load("Assets/Skybox/" + name + "/Front.png"), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load("Assets/Skybox/" + name + "/Back.png"), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load("Assets/Skybox/" + name + "/Up.png"), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load("Assets/Skybox/" + name + "/Down.png"), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load("Assets/Skybox/" + name + "/Right.png"), side: THREE.DoubleSide}),
      new THREE.MeshBasicMaterial ( { map: new THREE.TextureLoader().load("Assets/Skybox/" + name + "/Left.png"), side: THREE.DoubleSide})
    ];

    //Create new skybox using geometry and materials to replace current one
    skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
    //Add to the scene
    scene.add (skybox);
  }
  function updateSkyboxSize(){
    //Remove from scene
    scene.remove(skybox);
    //Duplicate materials
    var materials = skybox.material;
    //Create new geometry using updated size
    var skyboxGeometry = new THREE.CubeGeometry(skyboxSize, skyboxSize, skyboxSize);
    //Instantiate new skybox using old materials and new geometry
    skybox = new THREE.Mesh(skyboxGeometry, materials);
    //Add back scene
    scene.add(skybox);
  }
  //Scene
  function loadScene(){
    var loader = new THREE.GLTFLoader();
    var newGLTF = document.getElementById('NewGLTF').files[0];
    var gltfURL = URL.createObjectURL( newGLTF );

    loader.load( gltfURL, function ( gltf ) {
      scene = gltf.scene;

      gltf.scene.traverse( function ( child )
      {
        if (child instanceof THREE.Mesh)
        {
          Raycasts.push(child);
        }
      });
      console.log(scene);
	  },
	  // called while loading is progressing
	  function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); },
	  // called when loading has errors
	  function ( error ) { console.log( error ); }
  );}
  function saveScene(){
    var gltfExporter = new THREE.GLTFExporter();
    var options = {
      //Export position, translation and rotation instead of matrix per node
      trs: false,
      //Only export visable objects
      onlyVisible: true,
      //Only export object within the current drawing range
      truncateDrawRange: true,
      //Export as GLB
      binary: false,
      //Embed images into exported GLTF
      embedImages: true,
      //Generate indicies for non-index geometry
      forceIndices: false,
      //Export with images resized to power of two
      forcePowerOfTwoTextures: false
    };

    gltfExporter.parse( scene, function( result ) {
      var output = JSON.stringify( result, null, 2 );
      console.log( output );
      saveString( output, "Scene.gltf");
    }, options);
  }
  function clearScene() {
    while(scene.children.length > 0)
    {
      scene.remove(scene.children[0]);
      Raycasts = [];
      Lights = [];
    }
    toggleGrid();
    lightingPreset("Bright");
  }
  function save( blob, filename ) {
    var link = document.createElement( 'a' );
    link.style.display = 'none';
    document.body.appendChild( link );

    link.href = URL.createObjectURL( blob );
    link.download = filename;
    link.click();
  }
  function saveString( text, filename ) {
     save( new Blob( [ text ], { type: 'text/plain' } ), filename );
   }
  //Properties
  function removeObject(){
    //Remove transfrom controls from object
    control.detach();
    scene.remove( control );
    //Remove the object from the scene
    scene.remove(selectedObject);

    //Bool to search lights if it's not an object
    var removed = false;
    //Iterates through selectable objects
    for( var i = 0; i < Raycasts.length; i++){
      //Checks using uuid to remove the exact object
     if ( Raycasts[i].uuid === selectedObject.uuid) {
       //Removes object from raycasts array
       Raycasts.splice(i, 1);
       //Exits loop
       i = Raycasts.length;
       //Flips bool to not search through lights
       removed = true;
     }
    }
    if (!removed)
    {
      //Iterates through Lights array to find object
      for( var i = 0; i < Lights.length; i++){
       if ( Lights[i].uuid === selectedObject.uuid) {
         if(Lights[i].isDirectionalLight)
         {
           //Flips boolean so a new directional light can be added
           containsDirectional = false;
         }
         //Removes light from the array
         Lights.splice(i, 1);
         //Exits loop
         i = Lights.length;
       }
      }
    }
  }
  function updateProperties (obj) {
    //Clears material array to be populated with new materials
    objectMaterials = [];

    //Clears HTML elements in drop down menu
    var parentLocation = document.getElementById("MatListTop");
    while (parentLocation.firstChild) {
      parentLocation.removeChild(parentLocation.firstChild);
    }


    switch(obj.type)
    {
      //Case falls through from any type of light to directional
      case "SpotLight":
      case "PointLight":
      case "AmbientLight":
      case "DirectionalLight":
      {
        //Creates new hyperlink element
        var newA = document.createElement("a");
        newA.setAttribute('href', "#");
        //Sets function to fire on click
        newA.setAttribute("onclick","materialClick('-1')");
        //Creates visable "Colour" text
        var newContent = document.createTextNode("Colour");
        //Appends content to hyperlink object
        newA.appendChild(newContent);

        //Finds drop down menu for insertion
        var insertLocation = document.getElementById("MatListBottom");
        //Appends new element to the list
        parentLocation.insertBefore(newA, insertLocation);
        break;
      }

      //Multi-mesh model
      case "Group":
      {
        obj.traverse( function ( child )
        {
          if (child instanceof THREE.Mesh)
          {
            //Obtains the material array
            objectMaterials = child.material;
            //Iterates through each material in the model
            for(var idx = 0; idx < child.material.length; idx++)
            {
              //Creates new hyperlink element
              var newA = document.createElement("a");
              newA.setAttribute('href', "#");
              //Sets function to fire on click
              newA.setAttribute("onclick","materialClick('" + idx + "')");
              //Adds the material name as the content in the GUI
              var newContent = document.createTextNode(objectMaterials[idx].name);
              //Adds content to hyperlink element
              newA.appendChild(newContent);

              //Finds drop down menu for insertion
              var insertLocation = document.getElementById("MatListBottom");
              //Appends new element to material list
              parentLocation.insertBefore(newA, insertLocation);
            }
          }
        });
        break;
      }

      case "Mesh":
      {
        //Sets material as colour
        //With a primative you change the colour not the colour of the material
        objectMaterial = obj.color;
        //Creates new hyperlink element
        var newA = document.createElement("a");
        newA.setAttribute('href', "#");
        //Sets function to fire on click
        newA.setAttribute("onclick","materialClick('-2')");
        //Creates visable "Colour" text
        var newContent = document.createTextNode("Colour");
        //Appends content to hyperlink object
        newA.appendChild(newContent);

        //Finds drop down menu for insertion
        var insertLocation = document.getElementById("MatListBottom");
        //Appends new element to the list
        parentLocation.insertBefore(newA, insertLocation);
        break;
      }
    }
  }
  function materialClick(materialIdx) {
    //Mesh
    if(materialIdx == -2)
    {
      //Obtains the correct material from the object
      selectedMaterial = selectedObject.material;
      var header = document.getElementById("dropbtn");
      //Updates content of the button to show change in selection
      header.textContent = "Colour";
    }

    //Light
    else if(materialIdx == -1)
    {
      //Obtains the correct material from the object
      selectedMaterial = selectedObject;
      var header = document.getElementById("dropbtn");
      //Updates content of the button to show change in selection
      header.textContent = "Colour";
    }

    //Group
    else
    {
      //Obtains material using index of drop down menu
      selectedMaterial = objectMaterials[materialIdx];
      var header = document.getElementById("dropbtn");
      //Updates content of button with name of selected material
      header.textContent = objectMaterials[materialIdx].name;
    }
  }

  /* HTML JavaScript Extensions */
  //Sliding Nav Bar
  function openSideMenu() {
    //Updates style of elements to their open state
    document.getElementById('SettingsMenu').style.width = '250px';
    document.getElementById('SettingsMenu').style.fontSize = '100%';
    document.getElementById('SettingsMenu').style.opacity = '0.925';
    document.getElementById('SideBar').style.marginLeft = '250px';
    //Hides burger icon
    document.getElementById('burger').style.opacity = '0';
  }
  function closeSideMenu() {
    //Updates styles of elements to make them hide away as much as possible
    document.getElementById('SettingsMenu').style.width = '0px';
    document.getElementById('SettingsMenu').style.fontSize = '0px'
    document.getElementById('SettingsMenu').style.opacity = '0';
    document.getElementById('SideBar').style.marginLeft = '0px';
    //Shows the burger icon
    document.getElementById('burger').style.opacity = '1';
  }

  /* jquery */
  $(function(){

    //Enables mouse over colour selection
    var bCanPreview = true;

    //Create canvas and context objects for colour wheel
    var canvas = document.getElementById('ColourWheel');
    canvas.width /= 2;
    canvas.height = canvas.width;
    var ctx = canvas.getContext('2d');

    //Create new image for the colour wheel
    var image = new Image();

    //Load image from file
    var imageSrc = 'Assets/ColourWheel.png';
    image.src = imageSrc;

    //Draw the image on the canvas
    image.onload = function () {
      ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
    }

    $('#ColourWheel').mousemove(function(e) {
      //If selection has been made, colour isn't collected until the user clicks again
      if (bCanPreview) {
        //Maps mouse to correct image co-ordinates
        var canvasOffset = $(canvas).offset();
        var canvasX = Math.floor(e.pageX - canvasOffset.left);
        var canvasY = Math.floor(e.pageY - canvasOffset.top);

        //Get pixel at mouse position
        var imageData = ctx.getImageData(canvasX, canvasY, 1, 1);
        var pixel = imageData.data;
        var pixelColor = "rgb("+pixel[0]+", "+pixel[1]+", "+pixel[2]+")";

        //Update GUI with colour values
        $('#rVal').val(pixel[0]);
        $('#gVal').val(pixel[1]);
        $('#bVal').val(pixel[2]);
        $('#rgbVal').val(pixel[0]+','+pixel[1]+','+pixel[2]);

        //Calculate hex value
        var dColor = pixel[2] + 256 * pixel[1] + 65536 * pixel[0];
        $('#hexVal').val('#' + ('0000' + dColor.toString(16)).substr(-6));
        $('#hexVal').css('backgroundColor', pixelColor);

        //Update selected material of selected object
        if(selectedMaterial){
          selectedMaterial.color = new THREE.Color(pixelColor);
        }
      }
    });

    //Allows the user to click and select a colour on the colour wheel
    $('#ColourWheel').click(function(e) { bCanPreview = !bCanPreview; });

    //Prevents the raycaster from de-selecting an object when the GUI is being interacted with
    $('#SideBar').mouseover(function(e) { raycastEnabled = false; });
    $('#SideBar').mouseout(function(e) { raycastEnabled = true; });
    $('#Icons').mouseover(function(e) { raycastEnabled = false; });
    $('#Icons').mouseout(function(e) { raycastEnabled = true; });

  });
  </script>
</body>
</html>
